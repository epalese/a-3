#labels Phase-Requirements
#A-3 Overview

<h2> Introduction </h2>

A-3 is a Java framework that aims to help and simplify the implementation of self-management capabilities in highly dynamic and fully decentralised distributed applications.

<h2> Problem Specification </h2>
<p>
Typically in enterprise software systems a single well-defined entity or a set of collaborating entities are in charge of providing self-management properties. This is possible because enterprise environments are often characterised by a well known and controlled communicative and informational structure.
Instead scenarios with an high degree of dynamism and decentralisation make impossible a centralised approach to system management due to the lack of stable and well-defined entities to rely on. 
</p>

<p>
The role of A-3 is to address these kind of environments providing the tools to: 
<ul>
<li>build a self-organising control structure to get rid of dynamism and to build an accurate view of the running system</li>
<li>inject in running entities behavioural changes in order to adapt the system to environmental modification</li>
</ul>
</p>

A-3 provides the middleware to implement in a totally decentralised environment  a Monitor-Analyse-Plan-Execute control cycle which is at the heart of a self-managing software system.

<h2> Architecture </h2>
<p>
In a decentralised component-based system, self-managing behaviour cannot be limited to single components, but each must react and change based on the overall picture. Only trough adaptation at component-level the system can reach a global self-managing behaviour.  
Therefore, ideally, each component should gather enough and up-to-date information of the system configuration as well as how the other components are behaving. 
This is obviously difficult if the system is highly dynamic, and components are continuously entering and exiting the system.
</p>

<p>
In such a scenario we can't rely on a centralised supervision component and have all the other components send to it updated information regarding their behaviour. We are forced to adopt an entirely decentralised solution. In this case each component would need to communicate with all the others before being able to make a sound decision regarding what to do. This avoids having a single point of failure, but as soon as the number of nodes increase we have to face scalability issues since the messages exchanged will grow exponentially.
</p>

<p>
To get rid of these problems A-3 model introduces the notion of group.
A group represents a logical set of components that are brought together so that they can be supervised by a group leader.
A group leader is a regular component that has been dynamically elected to leader status. IT is responsible for gathering information about the components in its group, and for sharing its knowledge with other group leaders thanks to an exclusive group called the leader-group (see Figure 1). Groups use events to maintain a clear vision of the components they contain. This allows us to react to the addition or removal of a component, or the failure of a group leader. Moreover, when a leader fail we can promote a supervised component making it the new leader.
Scalability issues are addressed by the construction of a group hierarchy (as shown in Figure 1). The hierarchy to allow group leaders to exchange information about their respective groups enabling them to build a global view of the without the need to interact with every single component in the system.
</p>

<p>
A key aspect of our model is that the actual number of groups being used evolves together with the system at runtime. This is made possible through advanced group management features for dynamically creating or removing groups, and for migrating components from one group to another.
</p>

<p>
Our model is implemented through a layered architecture (see Figure 2).
<img src="https://a-3.googlecode.com/svn/wiki/images/LayeredArchitecture.png">
</p>